Hablemos de los mensajes y las colas. En la cafetería, hay cajeras que toman los pedidos de los clientes y baristas que hacen los pedidos. Actualmente, la cajera toma el pedido, lo escribe con un bolígrafo y un papel y entrega este pedido al barista. El barista toma entonces el papel y hace el pedido. Cuando llega el siguiente pedido, el proceso se repite. Esto funciona muy bien siempre que tanto la cajera como el barista estén sincronizados. Pero, ¿qué pasaría si la cajera tomara el pedido y se girara para pasárselo al barista, y éste estuviera fuera en su descanso u ocupado con otro pedido? Pues que la cajera se quedaría atascada hasta que el barista estuviera listo para tomar el pedido. Y en un momento dado, el pedido probablemente se retiraría para que la cajera pudiera ir a atender al siguiente cliente. Puede ver cómo se trata de un proceso defectuoso, porque en cuanto la cajera o el barista no estén sincronizados, el proceso se degradará. Provocando ralentizaciones en la recepción de pedidos y fallos a la hora de completar los pedidos en absoluto. Un proceso mucho mejor sería introducir algún tipo de buffer o cola en el sistema. En lugar de entregar el pedido directamente al barista, el cajero enviaría el pedido a algún tipo de buffer como un tablón de pedidos. Esta idea de colocar mensajes en un búfer se denomina mensajería y puesta en cola. Al igual que nuestra cajera envía pedidos al barista, las aplicaciones se envían mensajes entre sí para comunicarse. Si las aplicaciones se comunican directamente como nuestra cajera y barista anteriormente, esto se denomina estar estrechamente acopladas. Un rasgo distintivo de una arquitectura estrechamente acoplada es que si un solo componente falla o cambia, causa problemas a otros componentes o incluso a todo el sistema. Por ejemplo, si tenemos la aplicación A y está enviando mensajes directamente a la aplicación B. Si la aplicación B tiene un fallo y no puede aceptar esos mensajes, la aplicación A empezará a ver errores también. Esta es una arquitectura estrechamente acoplada. Una arquitectura más fiable está débilmente acoplada. Esta es una arquitectura en la que si un componente falla, está aislado y por lo tanto no causará fallos en cascada en todo el sistema. Si codificamos la aplicación para que utilice una arquitectura más débilmente acoplada, podría tener el siguiente aspecto, al igual que nuestro cajero y nuestro barista, introducimos un búfer entre los dos. En este caso, introducimos una cola de mensajes, los mensajes ascienden a la cola por la aplicación A y son procesados por la aplicación B. Si la aplicación B falla, la aplicación A no experimenta ninguna interrupción. Los mensajes que se envían pueden seguir enviándose a la cola y permanecerán allí hasta que finalmente se procesen. Esto es acoplamiento débil. Esto es lo que nos esforzamos por conseguir con las arquitecturas en AWS. Y esto me lleva a dos servicios de AWS que pueden ayudar en este sentido. Amazon Simple Queue Service o SQS, y Amazon Simple Notification Service o SNS. Pero antes de sumergirme en esos dos servicios, permítanme pedir un café para llevar en la página web de nuestra cafetería. Hecho. Muy bien, estupendo. Debería recibir un mensaje cuando el pedido esté listo. En primer lugar, hablemos de Amazon SQS. SQS le permite enviar, almacenar y recibir mensajes entre componentes de software de cualquier volumen. Todo ello sin perder mensajes ni requerir que otros servicios estén disponibles. Piense en los mensajes como nuestros pedidos de café, y en el tablón de pedidos como una cola SQS. Los mensajes tienen el nombre de la persona, el pedido de café y la hora a la que hizo el pedido. Los datos contenidos en su mensaje se denominan carga útil, y están protegidos hasta su entrega. Las colas SQS son donde se colocan los mensajes hasta que se procesan, y AWS administra la infraestructura subyacente para que usted aloje esas colas. Estas se escalan automáticamente, son fiables y fáciles de configurar y utilizar. Ahora bien, Amazon SNS es similar en el sentido de que se utiliza para enviar mensajes a los servicios, pero también puede enviar notificaciones a los usuarios finales. Lo hace de una manera diferente, denominada modelo publish/subscribe o pub/sub. Esto significa que puede crear algo llamado tema SNS, que no es más que un canal para que se envíen mensajes. A continuación, configura suscriptores a ese tema, y finalmente publica mensajes para esos suscriptores en la práctica. Esto significa que puede enviar un mensaje a un tema que luego se distribuirá a todos los suscriptores de una sola vez. Estos suscriptores también pueden ser puntos finales como colas SQS, funciones AWS Lambda y webhooks HTTPS o HTTP. Además, SNS puede utilizarse para distribuir notificaciones a los usuarios finales mediante push móvil, SMS y correo electrónico. Volviendo a nuestra cafetería, podríamos enviar una notificación cuando el pedido de un cliente esté listo. Podría ser un simple SMS para avisarle de que debe recogerlo o incluso un push móvil. [SONIDO] De hecho, parece que mi teléfono acaba de recibir un mensaje. Parece que mi pedido está listo. Hasta pronto.